{
  "version": 3,
  "sources": ["node-module-shim:module", "../src/registry.js", "../src/utils.js", "../src/decode.js", "../src/index.js", "../src/encode.js", "../src/http.js"],
  "sourcesContent": ["\n                // Browser shim for Node.js 'module' package\n                export function createRequire() {\n                    // In browser, return a require that always throws\n                    return function browserRequire(id) {\n                        throw new Error(`Cannot require '${id}' in browser environment`);\n                    };\n                }\n            ", "// Copyright 2025 Softwell S.r.l. - Licensed under Apache License 2.0\n/**\n * Type Registry for TYTX Base.\n *\n * Maps JavaScript types to/from TYTX suffixes.\n * Only scalar types are supported in base version.\n */\n\nimport { createRequire } from 'module';\nconst require = createRequire(import.meta.url);\n\n// =============================================================================\n// DECIMAL LIBRARY DETECTION\n// =============================================================================\n\n// Import all decimal libraries at startup\nlet DecimalJS = null;\nlet BigJS = null;\n\ntry { DecimalJS = require('decimal.js'); } catch {}\ntry { BigJS = require('big.js'); } catch {}\n\n// Current active class and library name\nlet DecimalClass = DecimalJS || BigJS || Number;\nlet decimalLibrary = DecimalJS ? 'decimal.js' : BigJS ? 'big.js' : 'number';\n\n/**\n * Set the decimal library to use.\n * @param {'decimal.js'|'big.js'|'number'} name\n */\nfunction setDecimalLibrary(name) {\n    if (name === 'decimal.js' && DecimalJS) {\n        DecimalClass = DecimalJS;\n        decimalLibrary = 'decimal.js';\n    } else if (name === 'big.js' && BigJS) {\n        DecimalClass = BigJS;\n        decimalLibrary = 'big.js';\n    } else {\n        DecimalClass = Number;\n        decimalLibrary = 'number';\n    }\n}\n\n/**\n * Get current decimal library name.\n * @returns {'decimal.js'|'big.js'|'number'}\n */\nfunction getDecimalLibrary() {\n    return decimalLibrary;\n}\n\n/**\n * Create a Decimal value using the current library.\n * @param {string|number} value\n * @returns {Decimal|Big|number}\n */\nfunction createDecimal(value) {\n    return new DecimalClass(value);\n}\n\n/**\n * Check if a value is a Decimal instance.\n * @param {any} value\n * @returns {boolean}\n */\nfunction isDecimal(value) {\n    if (decimalLibrary === 'number') {\n        return false;  // Cannot distinguish from regular Number\n    }\n    return value instanceof DecimalClass;\n}\n\n// =============================================================================\n// DATE TYPE DETECTION\n// =============================================================================\n\n/**\n * Determine the TYTX type for a Date object based on its content.\n * @param {Date} d\n * @returns {'D'|'H'|'DHZ'}\n */\nfunction getDateType(d) {\n    const isEpochDate = d.getUTCFullYear() === 1970 &&\n                        d.getUTCMonth() === 0 &&\n                        d.getUTCDate() === 1;\n    const isMidnight = d.getUTCHours() === 0 &&\n                       d.getUTCMinutes() === 0 &&\n                       d.getUTCSeconds() === 0 &&\n                       d.getUTCMilliseconds() === 0;\n\n    if (isEpochDate && !isMidnight) return 'H';   // time only\n    if (isMidnight && !isEpochDate) return 'D';   // date only\n    return 'DHZ';                                  // full datetime\n}\n\n// =============================================================================\n// SERIALIZERS (JavaScript type -> string)\n// =============================================================================\n\nfunction _serializeDecimal(v) {\n    return v.toString();\n}\n\nfunction _serializeDate(v) {\n    // Format: YYYY-MM-DD\n    const year = v.getUTCFullYear();\n    const month = String(v.getUTCMonth() + 1).padStart(2, '0');\n    const day = String(v.getUTCDate()).padStart(2, '0');\n    return `${year}-${month}-${day}`;\n}\n\nfunction _serializeDatetime(v) {\n    // Format: YYYY-MM-DDTHH:MM:SS.mmmZ (millisecond precision)\n    return v.toISOString();\n}\n\nfunction _serializeTime(v) {\n    // Format: HH:MM:SS.mmm\n    const hours = String(v.getUTCHours()).padStart(2, '0');\n    const minutes = String(v.getUTCMinutes()).padStart(2, '0');\n    const seconds = String(v.getUTCSeconds()).padStart(2, '0');\n    const millis = String(v.getUTCMilliseconds()).padStart(3, '0');\n    return `${hours}:${minutes}:${seconds}.${millis}`;\n}\n\nfunction _serializeBool(v) {\n    return v ? 'true' : 'false';\n}\n\nfunction _serializeInt(v) {\n    return v.toString();\n}\n\nfunction _serializeFloat(v) {\n    return v.toString();\n}\n\n// =============================================================================\n// TYPE REGISTRY\n// =============================================================================\n\n// Type detection and serialization\n// For JS we need functions to detect types since we can't use type() like Python\n\n/**\n * Get type entry for a value.\n * @param {any} value\n * @returns {[string, function, boolean]|null} [suffix, serializer, jsonNative] or null\n */\nfunction getTypeEntry(value) {\n    if (isDecimal(value)) {\n        return ['N', _serializeDecimal, false];\n    }\n    if (value instanceof Date) {\n        const dateType = getDateType(value);\n        if (dateType === 'D') {\n            return ['D', _serializeDate, false];\n        } else if (dateType === 'H') {\n            return ['H', _serializeTime, false];\n        } else {\n            return ['DHZ', _serializeDatetime, false];\n        }\n    }\n    if (typeof value === 'boolean') {\n        return ['B', _serializeBool, true];\n    }\n    if (typeof value === 'number') {\n        if (Number.isInteger(value)) {\n            return ['L', _serializeInt, true];\n        } else {\n            return ['R', _serializeFloat, true];\n        }\n    }\n    return null;\n}\n\n// =============================================================================\n// DESERIALIZERS (string -> JavaScript type)\n// =============================================================================\n\nfunction _deserializeDecimal(s) {\n    return createDecimal(s);\n}\n\nfunction _deserializeDate(s) {\n    // Input: YYYY-MM-DD\n    const [year, month, day] = s.split('-').map(Number);\n    return new Date(Date.UTC(year, month - 1, day, 0, 0, 0, 0));\n}\n\nfunction _deserializeDatetime(s) {\n    // Handle Z suffix\n    let str = s;\n    if (str.endsWith('Z')) {\n        str = str.slice(0, -1) + '+00:00';\n    }\n    return new Date(s);\n}\n\nfunction _deserializeTime(s) {\n    // Input: HH:MM:SS.mmm\n    const [h, m, rest] = s.split(':');\n    const [sec, ms] = rest.split('.');\n    return new Date(Date.UTC(1970, 0, 1, Number(h), Number(m), Number(sec), Number(ms || 0)));\n}\n\nfunction _deserializeBool(s) {\n    return s.toLowerCase() === 'true';\n}\n\nfunction _deserializeInt(s) {\n    return parseInt(s, 10);\n}\n\nfunction _deserializeFloat(s) {\n    return parseFloat(s);\n}\n\nfunction _deserializeStr(s) {\n    return s;\n}\n\nfunction _deserializeQs(s) {\n    // Lazy import to avoid circular dependency\n    const { fromQs } = require('./qs.js');\n    return fromQs(s);\n}\n\n// Suffix -> [type, deserializer] - includes all for decoding\n// Accepts both DH (deprecated) and DHZ (canonical) for datetime\nconst SUFFIX_TO_TYPE = {\n    'N': [Object, _deserializeDecimal],  // Object as placeholder for Decimal type\n    'D': [Date, _deserializeDate],\n    'DH': [Date, _deserializeDatetime],  // deprecated, still accepted\n    'DHZ': [Date, _deserializeDatetime], // canonical\n    'H': [Date, _deserializeTime],\n    'L': [Number, _deserializeInt],\n    'R': [Number, _deserializeFloat],\n    'T': [String, _deserializeStr],\n    'B': [Boolean, _deserializeBool],\n    'QS': [Object, _deserializeQs],\n};\n\nexport {\n    // Decimal utilities\n    decimalLibrary,\n    createDecimal,\n    isDecimal,\n    setDecimalLibrary,\n    getDecimalLibrary,\n    // Date type detection\n    getDateType,\n    // Type registry\n    getTypeEntry,\n    SUFFIX_TO_TYPE,\n    // Serializers (exported for testing)\n    _serializeDecimal,\n    _serializeDate,\n    _serializeDatetime,\n    _serializeTime,\n    _serializeBool,\n    _serializeInt,\n    _serializeFloat,\n    // Deserializers (exported for testing)\n    _deserializeDecimal,\n    _deserializeDate,\n    _deserializeDatetime,\n    _deserializeTime,\n    _deserializeBool,\n    _deserializeInt,\n    _deserializeFloat,\n    _deserializeStr,\n};\n", "// Copyright 2025 Softwell S.r.l. - Licensed under Apache License 2.0\n/**\n * TYTX Utilities.\n *\n * Provides:\n * - walk: recursive data structure transformation\n * - tytxEquivalent: semantic equivalence for roundtrip testing\n */\n\nimport { getTypeEntry, SUFFIX_TO_TYPE } from './registry.js';\n\n/**\n * Encode a scalar value to TYTX string with suffix.\n *\n * @param {any} value - JavaScript scalar value (Decimal, Date, boolean, number)\n * @param {boolean} forceSuffix - If true, force suffix for all types (including int/bool/float)\n * @returns {[boolean, string]} [encoded, result]\n *   - (true, \"serialized::SUFFIX\") if type is registered and needs suffix\n *   - (false, String(value)) if type not registered or jsonNative without force\n */\nfunction rawEncode(value, forceSuffix = false) {\n    const entry = getTypeEntry(value);\n    if (entry === null) {\n        return [false, String(value)];\n    }\n    const [suffix, serializer, jsonNative] = entry;\n    if (jsonNative && !forceSuffix) {\n        return [false, String(value)];\n    }\n    return [true, `${serializer(value)}::${suffix}`];\n}\n\n/**\n * Decode a string with TYTX suffix.\n *\n * @param {string} s - String possibly ending with ::XX where XX is a registered suffix\n * @returns {[boolean, any]} [decoded, value]\n *   - (true, decodedValue) if suffix found and decoded\n *   - (false, originalValue) if no valid suffix\n */\nfunction rawDecode(s) {\n    if (!s.includes('::')) {\n        return [false, s];\n    }\n    const lastIndex = s.lastIndexOf('::');\n    const value = s.slice(0, lastIndex);\n    const suffix = s.slice(lastIndex + 2);\n    const entry = SUFFIX_TO_TYPE[suffix];\n    if (entry === undefined) {\n        return [false, s];\n    }\n    const [, decoder] = entry;\n    return [true, decoder(value)];\n}\n\n/**\n * Walk a data structure and apply callback to values matching filtercb.\n *\n * @param {any} data - Data structure to walk\n * @param {function} callback - Function to apply to matching values\n * @param {function} filtercb - Filter function. Applies callback when filtercb(value) is true.\n * @returns {any} Transformed data\n */\nfunction walk(data, callback, filtercb) {\n    if (data !== null && typeof data === 'object' && !Array.isArray(data)) {\n        const result = {};\n        for (const [k, v] of Object.entries(data)) {\n            result[k] = walk(v, callback, filtercb);\n        }\n        return result;\n    }\n    if (Array.isArray(data)) {\n        return data.map(item => walk(item, callback, filtercb));\n    }\n    if (filtercb(data)) {\n        return callback(data);\n    }\n    return data;\n}\n\n/**\n * Truncate Date to milliseconds (TYTX precision).\n * @param {Date} dt\n * @returns {Date}\n */\nfunction _truncateToMillis(dt) {\n    // JavaScript Date already has millisecond precision, no truncation needed\n    return dt;\n}\n\n/**\n * Check if two Dates represent the same instant in time.\n *\n * TYTX serializes all datetimes as UTC (DHZ) with millisecond precision.\n * This function handles the semantic equivalence for roundtrip comparison.\n *\n * @param {Date} a - Original Date (before roundtrip)\n * @param {Date} b - Decoded Date (after roundtrip)\n * @returns {boolean} True if both represent the same instant in time\n */\nfunction datetimeEquivalent(a, b) {\n    // JavaScript Dates are always comparable directly in milliseconds\n    return a.getTime() === b.getTime();\n}\n\n/**\n * Check if two values are semantically equivalent after TYTX roundtrip.\n *\n * Handles special cases:\n * - Date: timestamp equivalence\n * - dict/list: recursive comparison\n * - other types: standard equality\n *\n * @param {any} a - Original value (before roundtrip)\n * @param {any} b - Decoded value (after roundtrip)\n * @returns {boolean} True if values are semantically equivalent\n */\nfunction tytxEquivalent(a, b) {\n    // Fast path: identical values\n    if (a === b) {\n        return true;\n    }\n\n    // Date special case\n    if (a instanceof Date && b instanceof Date) {\n        return datetimeEquivalent(a, b);\n    }\n\n    // dict: recursive comparison (needed to find nested Dates)\n    if (a !== null && typeof a === 'object' && !Array.isArray(a) &&\n        b !== null && typeof b === 'object' && !Array.isArray(b)) {\n        const keysA = Object.keys(a);\n        const keysB = Object.keys(b);\n        if (keysA.length !== keysB.length) {\n            return false;\n        }\n        const keysSetB = new Set(keysB);\n        for (const k of keysA) {\n            if (!keysSetB.has(k)) {\n                return false;\n            }\n        }\n        return keysA.every(k => tytxEquivalent(a[k], b[k]));\n    }\n\n    // list: recursive comparison (needed to find nested Dates)\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        return a.every((ai, i) => tytxEquivalent(ai, b[i]));\n    }\n\n    return false;\n}\n\nexport {\n    rawEncode,\n    rawDecode,\n    walk,\n    datetimeEquivalent,\n    tytxEquivalent,\n    _truncateToMillis,\n};\n", "// Copyright 2025 Softwell S.r.l. - Licensed under Apache License 2.0\n/**\n * TYTX Decoding - TYTX format to JavaScript objects.\n *\n * Supports multiple transports: json, xml, msgpack.\n */\n\nimport { walk, rawDecode } from './utils.js';\nimport { createRequire } from 'module';\nconst require = createRequire(import.meta.url);\n\nconst TYTX_MARKER = '::JS';\n\n/**\n * Filter for string values.\n * @param {any} v\n * @returns {boolean}\n */\nfunction isString(v) {\n    return typeof v === 'string';\n}\n\n/**\n * Decode a TYTX JSON string to JavaScript objects (internal).\n *\n * @param {string} data - JSON string with ::JS suffix (struct) or ::T suffix (scalar)\n * @returns {any} JavaScript object with typed values hydrated\n */\nfunction _fromJson(data) {\n    // Try rawDecode first (scalar with type suffix)\n    const [decoded, value] = rawDecode(data);\n    if (decoded) {\n        return value;\n    }\n\n    let jsonData = data;\n    if (jsonData.endsWith('::JS')) {\n        jsonData = jsonData.slice(0, -4);\n    }\n\n    let parsed;\n    try {\n        parsed = JSON.parse(jsonData);\n    } catch {\n        return data;\n    }\n\n    return walk(parsed, _decodeItem, isString);\n}\n\n/**\n * Decode a single item with TYTX suffix.\n * @param {string} s\n * @returns {any}\n */\nfunction _decodeItem(s) {\n    if (!s.includes('::')) {\n        return s;\n    }\n    return rawDecode(s)[1];\n}\n\n/**\n * Decode a TYTX XML string to JavaScript objects (internal).\n * @param {string} data\n * @returns {any}\n */\nfunction _fromXml(data) {\n    const { fromXml } = require('./xml.js');\n    const result = fromXml(data);\n    // If result is a string with TYTX suffix, hydrate it via JSON decoder\n    if (typeof result === 'string') {\n        return fromTytx(result);\n    }\n    return result;\n}\n\n/**\n * Decode TYTX MessagePack bytes to JavaScript objects (internal).\n * @param {Uint8Array} data\n * @returns {any}\n */\nfunction _fromMsgpack(data) {\n    const { fromMsgpack } = require('./msgpack.js');\n    return fromMsgpack(data);\n}\n\n/**\n * Decode TYTX format to JavaScript objects.\n *\n * @param {string|Uint8Array|null} data - Encoded data (string for json/xml, Uint8Array for msgpack), or null\n * @param {string|null} transport - Input format: \"json\", \"xml\", \"msgpack\", or null\n * @returns {any} JavaScript object with typed values hydrated, or null if data is null\n *\n * @example\n * fromTytx('{\"price\": \"100.50::N\"}::JS')\n * // {\"price\": Decimal(\"100.50\")}\n *\n * fromTytx('<root>100::N</root>', \"xml\")\n * // {\"root\": {\"attrs\": {}, \"value\": Decimal(\"100\")}}\n */\nfunction fromTytx(data, transport = null) {\n    if (data === null) {\n        return null;\n    }\n\n    if (transport === null || transport === 'json') {\n        let jsonData = data;\n        if (transport === 'json') {\n            jsonData = data.slice(1, -1);  // Remove surrounding quotes\n        }\n        return _fromJson(jsonData);\n    } else if (transport === 'xml') {\n        return _fromXml(data);\n    } else if (transport === 'msgpack') {\n        return _fromMsgpack(data);\n    } else {\n        throw new Error(`Unknown transport: ${transport}`);\n    }\n}\n\nexport {\n    fromTytx,\n    TYTX_MARKER,\n    isString,\n    _fromJson,\n    _fromXml,\n    _fromMsgpack,\n    _decodeItem,\n};\n", "// Copyright 2025 Softwell S.r.l. - Licensed under Apache License 2.0\n/**\n * TYTX Base - Typed Text Protocol for Scalar Types\n *\n * Minimal implementation supporting:\n * - Scalar types: Decimal, date, datetime, time, bool, int\n * - Encoders/Decoders: JSON, XML, MessagePack\n *\n * Usage:\n *     import { toTytx, fromTytx, fetchTytx } from 'genro-tytx';\n *     import Big from 'big.js';\n *\n *     // Encode\n *     const data = {\"price\": new Big(\"100.50\"), \"date\": new Date(Date.UTC(2025, 0, 15))};\n *     const jsonStr = toTytx(data);\n *     // '{\"price\": \"100.50::N\", \"date\": \"2025-01-15::D\"}::JS'\n *\n *     // Decode\n *     const result = fromTytx(jsonStr);\n *     // {\"price\": Big(\"100.50\"), \"date\": Date}\n */\n\nimport { isDecimal, createDecimal, setDecimalLibrary, getDecimalLibrary } from './registry.js';\n\nimport { toTytx } from './encode.js';\nimport { fromTytx } from './decode.js';\nimport { fetchTytx, getTransport, CONTENT_TYPES } from './http.js';\n\nconst __version__ = '0.7.4';\n\nexport {\n    // Core API\n    toTytx,\n    fromTytx,\n    // HTTP utilities\n    fetchTytx,\n    getTransport,\n    CONTENT_TYPES,\n    // Decimal utilities\n    isDecimal,\n    createDecimal,\n    setDecimalLibrary,\n    getDecimalLibrary,\n    // Version\n    __version__,\n};\n", "// Copyright 2025 Softwell S.r.l. - Licensed under Apache License 2.0\n/**\n * TYTX Encoding - JavaScript objects to TYTX format.\n *\n * Supports multiple transports: json, xml, msgpack.\n */\n\nimport { rawEncode } from './utils.js';\nimport { getTypeEntry } from './registry.js';\nimport { createRequire } from 'module';\nconst require = createRequire(import.meta.url);\n\n/**\n * Pre-process a value recursively, converting typed values to TYTX strings.\n * Returns [processedValue, hasSpecial].\n *\n * @param {any} value\n * @returns {[any, boolean]}\n */\nfunction _preprocessValue(value) {\n    // Check if value is a typed value that needs encoding\n    const entry = getTypeEntry(value);\n    if (entry !== null) {\n        const [suffix, serializer, jsonNative] = entry;\n        if (!jsonNative) {\n            return [`${serializer(value)}::${suffix}`, true];\n        }\n        // jsonNative types (bool, int, float) are kept as-is\n        return [value, false];\n    }\n\n    // Handle arrays\n    if (Array.isArray(value)) {\n        let hasSpecial = false;\n        const result = value.map(item => {\n            const [processed, special] = _preprocessValue(item);\n            if (special) hasSpecial = true;\n            return processed;\n        });\n        return [result, hasSpecial];\n    }\n\n    // Handle objects (but not null)\n    if (value !== null && typeof value === 'object') {\n        let hasSpecial = false;\n        const result = {};\n        for (const [k, v] of Object.entries(value)) {\n            const [processed, special] = _preprocessValue(v);\n            if (special) hasSpecial = true;\n            result[k] = processed;\n        }\n        return [result, hasSpecial];\n    }\n\n    // Primitive values (string, number, boolean, null)\n    return [value, false];\n}\n\n/**\n * Encode a JavaScript value to TYTX JSON string (internal).\n *\n * @param {any} value - JavaScript object to encode\n * @param {boolean} forceSuffix - If true, add suffix for all types (int/bool/float)\n * @returns {string} JSON string. For dict/list with typed values: adds ::JS suffix.\n */\nfunction _toJson(value, forceSuffix = false) {\n    const [encoded, result] = rawEncode(value, forceSuffix);\n    if (encoded) {\n        return result;\n    }\n\n    const [processed, hasSpecial] = _preprocessValue(value);\n    const jsonResult = JSON.stringify(processed);\n\n    if (hasSpecial) {\n        return `${jsonResult}::JS`;\n    }\n    return jsonResult;\n}\n\n/**\n * Encode a JavaScript value to TYTX MessagePack bytes (internal).\n * @param {any} value\n * @returns {Uint8Array}\n */\nasync function _toMsgpack(value) {\n    const { toMsgpack } = await import('./msgpack.js');\n    return toMsgpack(value);\n}\n\n/**\n * Encode a JavaScript value to raw JSON string (no TYTX suffix).\n * @param {any} value\n * @returns {string}\n */\nfunction _toRawJson(value) {\n    return JSON.stringify(value);\n}\n\n/**\n * Encode a JavaScript value to raw MessagePack bytes (no TYTX processing).\n * @param {any} value\n * @returns {Uint8Array}\n */\nfunction _toRawMsgpack(value) {\n    const msgpack = require('msgpack-lite');\n    return msgpack.encode(value);\n}\n\n/**\n * Encode a JavaScript value to TYTX format.\n *\n * @param {any} value - JavaScript object to encode\n * @param {string|null} transport - Output format: \"json\", \"xml\", \"msgpack\", or null\n * @param {Object} options - Options object\n * @param {boolean} options.raw - If true, output raw format without TYTX type suffixes\n * @param {boolean} options.qs - If true, output as query string format (flat object or array only)\n * @param {boolean} options._forceSuffix - Internal: force suffix for all types\n * @returns {string|Uint8Array} Encoded data (string for json/xml, Uint8Array for msgpack)\n *\n * @example\n * toTytx({\"price\": createDecimal(\"100.50\")})\n * // '{\"price\": \"100.50::N\"}::JS'\n *\n * toTytx({\"price\": 100.50}, null, { raw: true })\n * // '{\"price\": 100.5}'\n *\n * toTytx({\"alfa\": 33, \"date\": new Date(Date.UTC(2025, 11, 14))}, null, { qs: true })\n * // 'alfa=33::L&date=2025-12-14::D::QS'\n *\n * toTytx({\"root\": {\"value\": createDecimal(\"100\")}}, \"xml\")\n * // '<?xml version=\"1.0\" ?><root>100::N</root>'\n */\nfunction toTytx(value, transport = null, { raw = false, qs = false, _forceSuffix = false } = {}) {\n    if (qs) {\n        const { toQs } = require('./qs.js');\n        return `${toQs(value)}::QS`;\n    }\n\n    if (raw) {\n        if (transport === null || transport === 'json') {\n            return _toRawJson(value);\n        } else if (transport === 'msgpack') {\n            return _toRawMsgpack(value);\n        } else if (transport === 'xml') {\n            throw new Error('raw=true is not supported for XML transport');\n        } else {\n            throw new Error(`Unknown transport: ${transport}`);\n        }\n    }\n\n    if (transport === null || transport === 'json') {\n        const result = _toJson(value, _forceSuffix);\n        if (transport === 'json') {\n            return `\"${result}\"`;\n        }\n        return result;\n    } else if (transport === 'xml') {\n        // Lazy import to avoid circular dependency\n        const { toXml } = require('./xml.js');\n        const result = toXml(value);\n        return `<?xml version=\"1.0\" ?><tytx_root>${result}</tytx_root>`;\n    } else if (transport === 'msgpack') {\n        // Lazy import to avoid circular dependency\n        const { toMsgpack } = require('./msgpack.js');\n        return toMsgpack(value);\n    } else {\n        throw new Error(`Unknown transport: ${transport}`);\n    }\n}\n\nexport {\n    toTytx,\n    _toJson,\n    _toMsgpack,\n};\n", "// Copyright 2025 Softwell S.r.l. - Licensed under Apache License 2.0\n/**\n * TYTX HTTP utilities.\n *\n * Client-side functions to make HTTP requests with TYTX serialization.\n */\n\nimport { toTytx } from './encode.js';\nimport { fromTytx } from './decode.js';\n\nconst CONTENT_TYPES = {\n    json: 'application/json',\n    xml: 'application/xml',\n    msgpack: 'application/msgpack',\n};\n\n/**\n * Get transport from Content-Type header.\n * @param {string} contentType\n * @returns {'json'|'xml'|'msgpack'|null}\n */\nfunction getTransport(contentType) {\n    if (!contentType) return null;\n    const ct = contentType.toLowerCase();\n    if (ct.includes('json')) return 'json';\n    if (ct.includes('xml')) return 'xml';\n    if (ct.includes('msgpack')) return 'msgpack';\n    return null;\n}\n\n/**\n * Fetch with TYTX serialization/deserialization.\n *\n * @param {string} url - URL to fetch\n * @param {Object} options - Fetch options\n * @param {any} [options.body] - Data to send (will be serialized with toTytx)\n * @param {'json'|'xml'|'msgpack'} [options.transport='json'] - Transport format\n * @param {string} [options.method='GET'] - HTTP method\n * @param {Object} [options.headers={}] - Additional headers\n * @returns {Promise<any>} Deserialized response data\n */\nasync function fetchTytx(url, options = {}) {\n    const {\n        body,\n        transport = 'json',\n        method = body !== undefined ? 'POST' : 'GET',\n        headers = {},\n        ...fetchOptions\n    } = options;\n\n    const requestHeaders = {\n        'X-TYTX-Transport': transport,\n        ...headers,\n    };\n\n    // Serialize body if provided\n    let requestBody;\n    if (body !== undefined) {\n        requestHeaders['Content-Type'] = CONTENT_TYPES[transport];\n        const encoded = toTytx(body, transport);\n        if (transport === 'msgpack') {\n            requestBody = encoded;\n        } else {\n            requestBody = encoded;\n        }\n    }\n\n    // Make request\n    const response = await fetch(url, {\n        method,\n        headers: requestHeaders,\n        body: requestBody,\n        ...fetchOptions,\n    });\n\n    if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    // Determine response transport from Content-Type\n    const responseContentType = response.headers.get('Content-Type') || '';\n    const responseTransport = getTransport(responseContentType) || transport;\n\n    // Read and deserialize response\n    let responseData;\n    if (responseTransport === 'msgpack') {\n        const buffer = await response.arrayBuffer();\n        responseData = fromTytx(Buffer.from(buffer), responseTransport);\n    } else {\n        const text = await response.text();\n        responseData = fromTytx(text, responseTransport);\n    }\n\n    return responseData;\n}\n\nexport {\n    fetchTytx,\n    getTransport,\n    CONTENT_TYPES,\n};\n"],
  "mappings": "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",
  "names": ["require", "require", "import_meta", "import_meta", "require", "require"]
}
