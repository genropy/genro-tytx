<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: registry.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: registry.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * TYTX Type Registry
 *
 * Registry for pluggable data types.
 *
 * @module registry
 */

/**
 * @typedef {Object} DataType
 * @property {string} name - Human-readable name (e.g., "integer", "decimal")
 * @property {string} code - Short code used in TYTX syntax (e.g., "I", "D")
 * @property {string[]} aliases - Alternative codes/names
 * @property {string} js_type - JavaScript type name
 * @property {function(string): *} parse - Convert string to JS value
 * @property {function(*): string} serialize - Convert JS value to string
 */

class TypeRegistry {
    constructor() {
        /** @type {Map&lt;string, DataType>} */
        this._types = new Map();
        /** @type {Map&lt;string, DataType>} */
        this._codes = new Map();
        /** @type {Map&lt;string, DataType>} */
        this._aliases = new Map();
    }

    /**
     * Register a new data type.
     * @param {DataType} type_def - Type definition object
     */
    register(type_def) {
        this._types.set(type_def.name, type_def);
        this._codes.set(type_def.code, type_def);
        if (type_def.aliases) {
            for (const alias of type_def.aliases) {
                this._aliases.set(alias, type_def);
            }
        }
    }

    /**
     * Retrieve a type by name, code, or alias.
     * @param {string} name_or_code
     * @returns {DataType|null}
     */
    get(name_or_code) {
        return this._types.get(name_or_code)
            || this._codes.get(name_or_code)
            || this._aliases.get(name_or_code)
            || null;
    }

    /**
     * Get the type code for a JavaScript value.
     * Uses Genropy-compatible codes.
     * @param {*} value
     * @returns {string|null}
     */
    _get_type_code_for_value(value) {
        if (value === null || value === undefined) {
            return null;
        }
        if (typeof value === 'boolean') {
            return 'B';
        }
        if (typeof value === 'number') {
            return Number.isInteger(value) ? 'L' : 'R';  // Genropy: L for long/int, R for real/float
        }
        if (value instanceof Date) {
            // Check if it's date-only (time is 00:00:00)
            const has_time = value.getHours() !== 0
                || value.getMinutes() !== 0
                || value.getSeconds() !== 0
                || value.getMilliseconds() !== 0;
            return has_time ? 'DH' : 'D';  // Genropy: DH for datetime, D for date
        }
        if (Array.isArray(value) || (typeof value === 'object' &amp;&amp; value !== null)) {
            return 'JS';  // Genropy: JS for json
        }
        if (typeof value === 'string') {
            return null; // Strings don't get typed
        }
        return null;
    }

    /**
     * Check if a string contains a TYTX type suffix.
     * @param {string} text
     * @returns {boolean}
     */
    is_typed(text) {
        if (typeof text !== 'string' || !text.includes('::')) {
            return false;
        }
        const idx = text.lastIndexOf('::');
        const type_part = text.slice(idx + 2);
        return this.get(type_part) !== null;
    }

    /**
     * Parse a string to a JavaScript value.
     * @param {string} text - The string to parse. May contain embedded type (value::type).
     * @param {string} [type_code] - Optional explicit type code.
     * @returns {*} Parsed value, or original string if no type found.
     */
    from_text(text, type_code = null) {
        // If explicit type provided, use it
        if (type_code !== null) {
            const type_def = this.get(type_code);
            if (type_def) {
                return type_def.parse(text);
            }
            return text;
        }

        // Check for embedded type
        if (typeof text !== 'string' || !text.includes('::')) {
            return text;
        }

        // Split only on the last occurrence
        const idx = text.lastIndexOf('::');
        const val_part = text.slice(0, idx);
        const type_part = text.slice(idx + 2);

        const type_def = this.get(type_part);
        if (type_def) {
            return type_def.parse(val_part);
        }

        return text;
    }

    /**
     * Serialize a JavaScript object to a string (without type suffix).
     * @param {*} value - Value to serialize.
     * @param {string|boolean} [format] - Format string or true for default.
     * @param {string} [locale] - Locale string (e.g., "it-IT").
     * @returns {string}
     */
    as_text(value, format = null, locale = null) {
        if (typeof value === 'string') {
            return value;
        }

        const code = this._get_type_code_for_value(value);
        if (code) {
            const type_def = this.get(code);
            if (type_def) {
                if (format !== null &amp;&amp; type_def.format) {
                    return type_def.format(value, format, locale);
                }
                return type_def.serialize(value);
            }
        }

        return String(value);
    }

    /**
     * Serialize a JavaScript object to a typed string (value::type).
     * @param {*} value - Value to serialize.
     * @returns {string} String in format "value::type", or plain string if no type.
     */
    as_typed_text(value) {
        if (typeof value === 'string') {
            return value;
        }

        const code = this._get_type_code_for_value(value);
        if (code) {
            const type_def = this.get(code);
            if (type_def) {
                return type_def.serialize(value) + '::' + code;
            }
        }

        return String(value);
    }
}

// Global registry instance
const registry = new TypeRegistry();

module.exports = { TypeRegistry, registry };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-genro-tytx.html">genro-tytx</a></li><li><a href="module-json_utils.html">json_utils</a></li><li><a href="module-msgpack_utils.html">msgpack_utils</a></li><li><a href="module-registry.html">registry</a></li><li><a href="module-types.html">types</a></li><li><a href="module-tytx_model.html">tytx_model</a></li><li><a href="module-xml_utils.html">xml_utils</a></li></ul><h3>Classes</h3><ul><li><a href="module-tytx_model-TytxModel.html">TytxModel</a></li></ul><h3>Global</h3><ul><li><a href="global.html#dictToXml">dictToXml</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Sun Nov 30 2025 12:22:55 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
